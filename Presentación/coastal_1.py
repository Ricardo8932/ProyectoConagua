# -*- coding: utf-8 -*-
"""Coastal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Cx7mF_mTc-yA6sdvrbaKK0r7W7A1v_jn

<h1>Aplicación de técnicas de inteligencia artificial para evaluar la calidad del agua</h1>

<h2>Introducción</h2>

<p style="text-align: justify;">La Comisión Nacional del Agua (CONAGUA) es una dependencia del gobierno de México, encargada de mmonitorear y gestionar los cuerpos de aguas superficiales (lóticos, lénticos y costeros) y subterráneos del país</p>

<p style="text-align: justify;">El análisis de la calidad del agua superficial consideró 8 parámetros indicadores: Demanda Bioquímica de Oxígeno a cinco días (DBO5), Demanda Química de Oxígeno (DQO), Sólidos Suspendidos Totales (SST), Coliformes fecales (CF), Escherichia coli, (E_COLI), Enterococos fecales (ENTEROC_FEC), porcentaje de saturación de Oxígeno Disuelto (OD%) y Toxicidad aguda (TOX).</p>

<p style="text-align: justify;">La calidad del agua en sitios superficiales y subterráneos se categoriza a través de un semaforo el cual considera 3 colores, verde, amarillo y rojo, dependiendo el cumplimiento de los contaminantes con la regulación mexicana (DOF, 2023), amarillo cuando se incumple uno o más de los siguientes parámetros: E_COLI, CF, SST y OD%; rojo cuando existe incumplimiento en uno o más de los siguientes parámetros: DBO5, DQO, TOX y ENTEROC_FEC.</p>

<h2>Planteamiento del problema y justificación</h2>

<p style="text-align: justify;">La contaminación del agua en cuerpos superficiales y subterráneos es un problema ambiental creciente que afecta la calidad y disponibilidad del agua potable. La prescencia de contaminantes en estos cuerpos de agua representa un riesgo para la salud humana y los ecosistemas acuáticos.</p>

<p style="text-align: justify;">Este trabajo propone un sistema automatizado que por ahora está considerando solo los contaminantes que usa CONAGUA, pero que en un futuro es posible y sencillo agregar más variables de entrada si los datos medidos se encuentran disponibles.</p>

<h2>Objetivo General</h2>

<p style="text-align: justify;">El objetivo general de este proyecto es desarrollar un modelo de clasificacíon de la calidad del agua de cuerpos superficiales y subterráneos usando técnicas de aprendizaje automático y la base de datos reportada por CONAGUA.</p>

<h2>Objetivos Específicos</h2>

*   Descargar la base de datos del 2012-2022 que es reportada por CONAGUA, incluyendo los parámetros fisicoquímicos y microbiológicos, y otros metadatos.
*   Preprocesar los datos, incluyendo la limpieza, transformación y seleccion de características para el modelo de clasificación.
*   Entrenar y evaluar los modelos de clasificación basados en XGBoost, SVM, KNN, DT y MLR utilizando técnicas de validación cruzada y busqueda de hiperparámetros.
*   Comparar los modelos considerando diversas métricas de evaluación y seleccionar el mejor modelo para cada tipo de agua.
*   Desarrollar una aplicación con interfaz gráfica que estara disponible para que los usuarios apliquen el nuevo enfoque de clasificación.
*   Aplicar el nuevo enfoque de clasificación a los datos medidos en 2022 por CONAGUA.

<h2>Metodología</h2>

![work_methodology.jpg](data:image/jpeg;base64,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qEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfDvb9ivLG6vts898WqhAFVe9v2K8sbq+2zz3w72/Yryxur7bPPfFqoQBVXvb9ivLG6vts898O9v2K8sbq+2zz3xaqEAVV72/Yryxur7bPPfGE3VsXcDRvSz2/e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)

<h2>Cross Validation</h2>

![cross-validation.jpg](data:image/jpeg;base64,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)

<h2>Métricas de evaluación</h2>

**Accuracy (Exactitud)**

La exactitud es una medida general de que tan bien un modelo clasifica correctamente las muestras. Se calcula como el número de predicciones correctas dividido por el número total de muestras.

**Precision (Precisión)**

La precisión mide la proporción de verdaderos positivos entre todos los casos clasificados como positivos entre todos los casos clasificados como positivos por el modelo. Es una medidad de cuántas de las instancias clasificadas como positivas realmente lo son.

**Recall (Recuperación o Sensibilidad)**

El recall mide la proporción de verdaderos positivos que fueron correctamente identificados por el modelo entre todos los casos que realmente son positivos. Es una medida de cuántas de las instancias positivas el modelo fue capaz de capturar.

**F1 Score**

El F1 Score es la medida armónica entre la precisión y el recall. Es una medidad que combina ambas métricas en una sola, útil cuando hay un desbalance entre las clases.

**Matriz de Confusión**

Una matriz de confusión es una tabla que muestra el desempeño de un modelo de clasificación en terminos de verdaderos positivos, falsos positivos, verdaderos negativos y falsos negativos. Es una forma visual de entender como el modelo esta haciendo sus predicciones.
La matriz tiene dos dimensiones: las filas representas las clases reales y las columnas representan las clases predichas por el modelo.

<h2>Ejemplo de clasificación de pacientes para entender estos conceptos:</h2>


Imagina que estás trabajando en un hospital y tienes un modelo de clasificación que intenta predecir si un paciente tiene una enfermedad basándose en los resultados de una prueba médica.

True Positive (Verdadero Positivo, TP): Esto sucede cuando el modelo predice correctamente que un paciente tiene la enfermedad (positivo) cuando en realidad la tiene (verdadero). Es decir, el modelo acierta al clasificar un paciente enfermo como enfermo.

False Positive (Falso Positivo, FP): Esto ocurre cuando el modelo predice incorrectamente que un paciente tiene la enfermedad (positivo) cuando en realidad no la tiene (negativo). En otras palabras, el modelo se equivoca al clasificar un paciente sano como enfermo.

True Negative (Verdadero Negativo, TN): Sucede cuando el modelo predice correctamente que un paciente no tiene la enfermedad (negativo) cuando en realidad no la tiene (verdadero). Es decir, el modelo acierta al clasificar un paciente sano como sano.

False Negative (Falso Negativo, FN): Esto ocurre cuando el modelo predice incorrectamente que un paciente no tiene la enfermedad (negativo) cuando en realidad la tiene (positivo). En resumen, el modelo se equivoca al clasificar un paciente enfermo como sano.

#Coastal

Import the necessary libraries
"""

#Import the necessary libraries
import warnings

# Ignore FutureWarnings
warnings.simplefilter(action='ignore', category=FutureWarning)

import pickle
import joblib
import numpy as np
import matplotlib.pyplot as plt
import plotly.io as pio
import pandas as pd
import seaborn as sns
from sklearn.metrics import accuracy_score, precision_score, f1_score, confusion_matrix, recall_score, matthews_corrcoef, roc_auc_score, jaccard_score, log_loss
from sklearn.preprocessing import StandardScaler
from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score
from imblearn.under_sampling import RandomUnderSampler
from collections import Counter
from sklearn.tree import DecisionTreeClassifier
from xgboost import XGBClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelBinarizer

"""Load the data set"""

# Load coastal data from Excel file into a DataFrame
df_coastal = pd.read_excel("https://raw.githubusercontent.com/Ricardo8932/ProyectoConagua/main/Database/Coastal/coastal_results.xlsx")

# Creates a new DataFrame for nullity matrix (nm) from the years 2012 to 2021, excluding data for the year 2022
df_nm_2012_2021 = df_coastal[df_coastal['AÑO'] != 2022]

# Creates a new DataFrame for nullity matrix (nm) consisting only of data from the year 2022
df_nm_2022 = df_coastal[df_coastal['AÑO'] == 2022]

df_coastal.info()

# Display the first 5 rows of the coastal DataFrame
df_coastal.head(5)

#Replace "<, ≤, >, ≥" with ""
columns = df_coastal.columns.values

df_coastal[columns] = df_coastal[columns].replace({'<':''}, regex=True)
df_coastal[columns] = df_coastal[columns].replace({'>':''}, regex=True)
df_coastal[columns] = df_coastal[columns].replace({'≤':''}, regex=True)
df_coastal[columns] = df_coastal[columns].replace({'≥':''}, regex=True)

columnas_seleccionadas = df_coastal.iloc[:, 6:14]
columnas_seleccionadas.head()

# Check the first 5 rows of the coastal DataFrame to verify if '<, ≤' and '>, ≥' signs have been removed
df_coastal.head(5)

# Selecciona el rango de columnas que deseas convertir
columnas_a_convertir = df_coastal.columns[6:14]  # 6:14 selecciona las columnas de la 6 a la 18

# Aplica pd.to_numeric a las columnas seleccionadas
df_coastal[columnas_a_convertir] = df_coastal[columnas_a_convertir].apply(pd.to_numeric, errors='coerce')

df_coastal.info()

# Change the data type of contaminant columns from object to float64
df_coastal = df_coastal.astype({'AÑO':'object','TSS':'float64','FC':'float64','ODs%':'float64','ODm%':'float64','ODb%':'float64','FE':'float64','TF15s':'float64','TF15b':'float64'})

# Display summary statistics of the coastal DataFrame
df_coastal.describe()

# Display the shape of the coastal DataFrame (number of rows and columns)
df_coastal.shape

# Remove rows with missing values from the coastal DataFrame
df_coastal = df_coastal.dropna()

# Verify that rows with missing values have been removed from the coastal DataFrame
df_coastal.info()

# Exporting preprocessed dataset to Excel file.
# This code creates an Excel file of the preprocessed dataset, which has no missing values or unusual characters.
df_coastal.to_excel("coastal_preprocessed.xlsx")

# Select the columns you want to include in the heatmap
selected_columns_coastal_2012_2021 = df_nm_2012_2021.columns[6:14]  # Replace with the range of column names you want

# Create a heatmap of missing values for only the selected columns
plt.figure(figsize=(7,3))  # Adjust the size of the figure

# Generates a heat map showing the presence of missing values in selected columns
heatmap = sns.heatmap(df_nm_2012_2021[selected_columns_coastal_2012_2021].isnull(), cbar=False, cmap='Blues_r')

# Rotate the x-axis labels by 90 degrees so they are vertical and increase the font size
heatmap.set_xticklabels(heatmap.get_xticklabels(), rotation=90, fontsize=17)

# Remove the y-axis ticks and labels
heatmap.set_yticks([])
heatmap.set_yticklabels([])

plt.title('Coastal (2012-2021)', loc='center', fontsize=20)
plt.xlabel('', loc='center', fontsize=20)
plt.show()

# Select the columns you want to include in the heatmap
selected_columns_coastal_2022 = df_nm_2022.columns[6:14]  # Replace with the range of column names you want

# Create a heatmap of missing values for only the selected columns
plt.figure(figsize=(7,3))  # Adjust the size of the figure

# Generates a heat map showing the presence of missing values in selected columns
heatmap = sns.heatmap(df_nm_2022[selected_columns_coastal_2022].isnull(), cbar=False, cmap='Blues_r')

# Rotate the x-axis labels by 90 degrees so they are vertical and increase the font size
heatmap.set_xticklabels(heatmap.get_xticklabels(), rotation=90, fontsize=17)

# Remove the y-axis ticks and labels
heatmap.set_yticks([])
heatmap.set_yticklabels([])

plt.title('Coastal (2022)', loc='center', fontsize=20)
plt.xlabel('', loc='center', fontsize=20)
plt.show()

#Realizar un analisis exploratorio de los datos anteriores, como matriz de nulidad, y grafica de correlacion y otro tipo de gracicas para el analisis exploratorio

"""Functions for the 'quality_' and 'complies_' columns

"""

# Create a new DataFrame 'data_coastal' by assigning NaN values to columns for water quality and compliance for each contaminant
data_coastal = df_coastal.assign(quality_TSS=np.nan,quality_FC=np.nan,quality_ODs=np.nan,quality_ODm=np.nan,quality_ODb=np.nan,quality_FE=np.nan,quality_TF15s=np.nan,quality_TF15b=np.nan,
                                complies_TSS=np.nan,complies_FC=np.nan,complies_ODs=np.nan,complies_ODm=np.nan,complies_ODb=np.nan,complies_FE=np.nan,complies_TF15s=np.nan,complies_TF15b=np.nan)

data_coastal.columns

# Display general information about the new columns added to the data_coastal DataFrame
data_coastal.info()

"""Function for the 'quality_' column"""

#---------------------------quality_TSS---------------------------------------------------------------------------------
col = 'TSS'
conditions  = [ data_coastal[col] <= 25, (data_coastal[col] > 25) & (data_coastal[col] <= 75), (data_coastal[col] > 75) & (data_coastal[col] <= 150), (data_coastal[col] > 150) & (data_coastal[col] <= 400), data_coastal[col] > 400 ]
choices     = [ 'Excelente', 'Buena calidad', 'Aceptable', 'Contaminada', 'Fuertemente contaminada']
data_coastal['quality_TSS'] = np.select(conditions, choices, default=np.nan)

#---------------------------quality_FC-------------------------------------------------------------------
col = 'FC'
conditions  = [ data_coastal[col] <= 100, (data_coastal[col] > 100) & (data_coastal[col] <= 200), (data_coastal[col] > 200) & (data_coastal[col] <= 1000), (data_coastal[col] > 1000) & (data_coastal[col] <= 10000), data_coastal[col] > 10000 ]
choices     = [ 'Excelente', 'Buena calidad', 'Aceptable', 'Contaminada', 'Fuertemente contaminada']
data_coastal['quality_FC'] = np.select(conditions, choices, default=np.nan)

#---------------------------quality_ODs-------------------------------------------------------------------------
col = 'ODs%'
conditions  = [ (data_coastal[col] > 70) & (data_coastal[col] <= 110),
                (((data_coastal[col] > 50) & (data_coastal[col] <= 70))|((data_coastal[col] > 110)&(data_coastal[col] <= 120))),
                (((data_coastal[col] > 30) & (data_coastal[col] <= 50))|((data_coastal[col] > 120)&(data_coastal[col] <= 130))),
                (((data_coastal[col] > 10) & (data_coastal[col] <= 30))|((data_coastal[col] > 130)&(data_coastal[col] <= 150))),
                ((data_coastal[col] <= 10)|(data_coastal[col] > 150)) ]
choices     = [ 'Excelente', 'Buena calidad', 'Aceptable', 'Contaminada', 'Fuertemente contaminada']
data_coastal['quality_ODs'] = np.select(conditions, choices, default=np.nan)


#---------------------------quality_ODm-------------------------------------------------------------------------
col = 'ODm%'
conditions  = [ (data_coastal[col] > 70) & (data_coastal[col] <= 110),
                (((data_coastal[col] > 50) & (data_coastal[col] <= 70))|((data_coastal[col] > 110)&(data_coastal[col] <= 120))),
                (((data_coastal[col] > 30) & (data_coastal[col] <= 50))|((data_coastal[col] > 120)&(data_coastal[col] <= 130))),
                (((data_coastal[col] > 10) & (data_coastal[col] <= 30))|((data_coastal[col] > 130)&(data_coastal[col] <= 150))),
                ((data_coastal[col] <= 10)|(data_coastal[col] > 150)) ]
choices     = [ 'Excelente', 'Buena calidad', 'Aceptable', 'Contaminada', 'Fuertemente contaminada']
data_coastal['quality_ODm'] = np.select(conditions, choices, default=np.nan)

#---------------------------quality_ODb-------------------------------------------------------------------------
col = 'ODb%'
conditions  = [ (data_coastal[col] > 70) & (data_coastal[col] <= 110),
                (((data_coastal[col] > 50) & (data_coastal[col] <= 70))|((data_coastal[col] > 110)&(data_coastal[col] <= 120))),
                (((data_coastal[col] > 30) & (data_coastal[col] <= 50))|((data_coastal[col] > 120)&(data_coastal[col] <= 130))),
                (((data_coastal[col] > 10) & (data_coastal[col] <= 30))|((data_coastal[col] > 130)&(data_coastal[col] <= 150))),
                ((data_coastal[col] <= 10)|(data_coastal[col] > 150)) ]
choices     = [ 'Excelente', 'Buena calidad', 'Aceptable', 'Contaminada', 'Fuertemente contaminada']
data_coastal['quality_ODb'] = np.select(conditions, choices, default=np.nan)

#---------------------------quality_FE--------------------------------------------------------------------------------
col = 'FE'
conditions  = [ data_coastal[col] <= 100, (data_coastal[col] > 100) & (data_coastal[col] <= 200), (data_coastal[col] > 200) & (data_coastal[col] <= 500), data_coastal[col] > 500 ]
choices     = [ 'Excelente', 'Buena calidad', 'Contaminada', 'Fuertemente contaminada']
data_coastal['quality_FE'] = np.select(conditions, choices, default=np.nan)

#---------------------------quality_TF15s---------------------------------------------------------------------
col = 'TF15s'
conditions  = [(data_coastal[col] < 1), (data_coastal[col] >= 1) & (data_coastal[col] <= 1.33), (data_coastal[col] > 1.33) & (data_coastal[col] < 5), data_coastal[col] >= 5 ]
choices     = [ 'No tóxico', 'Toxicidad baja', 'Toxicidad moderada', 'Toxicidad alta' ]
data_coastal['quality_TF15s'] = np.select(conditions, choices, default=np.nan)


#---------------------------quality_TF15b---------------------------------------------------------------------
col = 'TF15b'
conditions  = [(data_coastal[col] < 1), (data_coastal[col] >= 1) & (data_coastal[col] <= 1.33), (data_coastal[col] > 1.33) & (data_coastal[col] < 5), data_coastal[col] >= 5 ]
choices     = [ 'No tóxico', 'Toxicidad baja', 'Toxicidad moderada', 'Toxicidad alta' ]
data_coastal['quality_TF15b'] = np.select(conditions, choices, default=np.nan)

data_coastal.iloc[:5, 14:21] #Columnas tipo de quality_

"""Function for the 'complies_' column"""

#---------------------------complies for quality_TSS-----------------------------------------------------
col = 'quality_TSS'
conditions  = [ data_coastal[col] == 'Excelente', data_coastal[col] == 'Buena calidad', data_coastal[col] == 'Aceptable', data_coastal[col] == 'Contaminada', data_coastal[col] == 'Fuertemente contaminada']
choices     = [ 1, 1, 1, 0, 0 ]
data_coastal['complies_TSS'] = np.select(conditions, choices, default=np.nan)
data_coastal['complies_TSS'] = data_coastal['complies_TSS'].astype('int32')

#---------------------------complies for quality_FC-----------------------------------------------------
col = 'quality_FC'
conditions  = [ data_coastal[col] == 'Excelente', data_coastal[col] == 'Buena calidad', data_coastal[col] == 'Aceptable', data_coastal[col] == 'Contaminada', data_coastal[col] == 'Fuertemente contaminada']
choices     = [ 1, 1, 1, 0, 0 ]
data_coastal['complies_FC'] = np.select(conditions, choices, default=np.nan)
data_coastal['complies_FC'] = data_coastal['complies_FC'].astype('int32')

#---------------------------complies for quality_ODs-----------------------------------------------------
col = 'quality_ODs'
conditions  = [ data_coastal[col] == 'Excelente', data_coastal[col] == 'Buena calidad', data_coastal[col] == 'Aceptable', data_coastal[col] == 'Contaminada', data_coastal[col] == 'Fuertemente contaminada']
choices     = [ 1, 1, 1, 0, 0 ]
data_coastal['complies_ODs'] = np.select(conditions, choices, default=np.nan)
data_coastal['complies_ODs'] = data_coastal['complies_ODs'].astype('int32')

#---------------------------complies for quality_ODm-----------------------------------------------------
col = 'quality_ODm'
conditions  = [ data_coastal[col] == 'Excelente', data_coastal[col] == 'Buena calidad', data_coastal[col] == 'Aceptable', data_coastal[col] == 'Contaminada', data_coastal[col] == 'Fuertemente contaminada']
choices     = [ 1, 1, 1, 0, 0 ]
data_coastal['complies_ODm'] = np.select(conditions, choices, default=np.nan)
data_coastal['complies_ODm'] = data_coastal['complies_ODm'].astype('int32')

#---------------------------complies for quality_ODb-----------------------------------------------------
col = 'quality_ODb'
conditions  = [ data_coastal[col] == 'Excelente', data_coastal[col] == 'Buena calidad', data_coastal[col] == 'Aceptable', data_coastal[col] == 'Contaminada', data_coastal[col] == 'Fuertemente contaminada']
choices     = [ 1, 1, 1, 0, 0 ]
data_coastal['complies_ODb'] = np.select(conditions, choices, default=np.nan)
data_coastal['complies_ODb'] = data_coastal['complies_ODb'].astype('int32')

#---------------------------complies for quality_FE-----------------------------------------------------
col = 'quality_FE'
conditions  = [ data_coastal[col] == 'Excelente', data_coastal[col] == 'Buena calidad', data_coastal[col] == 'Contaminada', data_coastal[col] == 'Fuertemente contaminada']
choices     = [ 1, 1, 0, 0 ]
data_coastal['complies_FE'] = np.select(conditions, choices, default=np.nan)
data_coastal['complies_FE'] = data_coastal['complies_FE'].astype('int32')

#---------------------------complies for quality_TF15s-----------------------------------------------------
col = 'quality_TF15s'
conditions  = [ data_coastal[col] == 'No tóxico', data_coastal[col] == 'Toxicidad baja', data_coastal[col] == 'Toxicidad moderada', data_coastal[col] == 'Toxicidad alta']
choices     = [ 1, 1, 1, 0 ]
data_coastal['complies_TF15s'] = np.select(conditions, choices, default=np.nan)
data_coastal['complies_TF15s'] = data_coastal['complies_TF15s'].astype('int32')

#---------------------------complies for quality_TF15b-----------------------------------------------------
col = 'quality_TF15b'
conditions  = [ data_coastal[col] == 'No tóxico', data_coastal[col] == 'Toxicidad baja', data_coastal[col] == 'Toxicidad moderada', data_coastal[col] == 'Toxicidad alta']
choices     = [ 1, 1, 1, 0 ]
data_coastal['complies_TF15b'] = np.select(conditions, choices, default=np.nan)
data_coastal['complies_TF15b'] = data_coastal['complies_TF15b'].astype('int32')

data_coastal.iloc[:5, 22:]

"""Assignment of water quality"""

conditions  = [(data_coastal['complies_TF15s'] == 0) | (data_coastal['complies_TF15b'] == 0) | (data_coastal['complies_FE'] == 0),
               (data_coastal['complies_FC'] == 0) | (data_coastal['complies_TSS'] == 0) | (data_coastal['complies_ODs'] == 0) | (data_coastal['complies_ODm'] == 0) | (data_coastal['complies_ODb'] == 0),
               (data_coastal['complies_FC'] == 1) & (data_coastal['complies_TF15s'] == 1) & (data_coastal['complies_TF15b'] == 1) & (data_coastal['complies_ODs'] == 1) & (data_coastal['complies_ODm'] == 1) & (data_coastal['complies_ODb'] == 1) & (data_coastal['complies_FE'] == 1) & (data_coastal['complies_TSS'] == 1)]
choices     = [2, 1, 0]
data_coastal['Water quality'] = np.select(conditions, choices, default=np.nan)
data_coastal['Water quality'] = data_coastal['Water quality'].astype('int32')

data_coastal.iloc[:5, 22:]

data_coastal.to_excel("coastal_complete.xlsx")

df_coastal_water_quality = data_coastal.iloc[:, list(range(0, 14)) + [30]]
df_coastal_water_quality.info()

df_coastal_water_quality.to_excel("coastal_water-quality.xlsx")

# Agrupar por año y contar los valores de la columna "Water quality" para cada grupo
conteo_por_año = df_coastal_water_quality.groupby('AÑO')['Water quality'].value_counts().unstack(fill_value=0)

# Mostrar el resultado
print(conteo_por_año)

conteo_por_año = conteo_por_año.T

# Obtener el número de valores de la clase 0 para el año 2015
num_clase_0_2015 = conteo_por_año.loc[0, 2015]
print("Número de valores de la clase 0 en el año 2015:", num_clase_0_2015)

#Coastal
import pandas as pd
import matplotlib.pyplot as plt

# Crear datos
df = pd.DataFrame([['2012', 195, 41, 16], ['2013', 829, 371, 111], ['2014', 809, 226, 99], ['2015', 643, 127, 57], ['2016', 586, 133, 39], ['2017', 430, 68, 62], ['2018', 349, 33, 46], ['2019', 41, 4, 4], ['2020', 0, 0, 0], ['2021', 0, 0, 0], ['2022', 16, 5, 0]],
                  columns=['Year', 'Good', 'Regular', 'Poor'])

# Definir colores para cada valor
colors = ["green", "orange", "red"]  # Puedes ajustar los colores según tus preferencias

# Ajustar el tamaño del gráfico
plt.figure(figsize=(15, 6))

# Ajustar la separación entre barras y el ancho de las barras
bar_width = 0.27  # Ajusta este valor para hacer las barras más delgadas
bar_positions = range(len(df["Year"]))

# Barra Good
bar1 = plt.bar(bar_positions, df["Good"], width=bar_width, color=colors[0], edgecolor='black', label="Good")

# Barra Regular
bar2 = plt.bar([pos + bar_width for pos in bar_positions], df["Regular"], width=bar_width, color=colors[1], edgecolor='black', label="Regular")

# Barra Poor
bar3 = plt.bar([pos + 2*bar_width for pos in bar_positions], df["Poor"], width=bar_width, color=colors[2], edgecolor='black', label="Poor")

plt.ylabel('', fontsize=15)
plt.xlabel('')
plt.title('d)', fontsize=20)  # Ajusta el tamaño del título según tus preferencias


# Ajustar las etiquetas del eje x
new_positions = [pos + 1.5 * bar_width for pos in bar_positions]
plt.xticks(new_positions, df["Year"], fontsize=15)

# Aumentar el tamaño de las etiquetas del eje y
plt.yticks(fontsize=15)

# Añadir valores dentro de cada barra con fuente más grande y en negrita
#for bar, category in zip([bar1, bar2, bar3], ["Good", "Regular", "Poor"]):
#    plt.bar_label(bar, label_type='edge', labels=df[category], fontsize=12, fontweight='bold', color='black')

# Quitar el cuadriculado
plt.grid(False)

# Mover la leyenda fuera de las barras
#plt.legend(bbox_to_anchor=(0, 1), loc='upper left')

# Mostrar el gráfico
plt.show()

# Creates a new DataFrame for model training from the years 2012 to 2021, excluding data for the year 2022
df_train_coastal = data_coastal[data_coastal['AÑO'] != 2022]

# Creates a new DataFrame for validation consisting only of data from the year 2022
df_val_coastal = data_coastal[data_coastal['AÑO'] == 2022]

# Displays the size of the training DataFrame
df_train_coastal.shape

# Displays the size of the validation DataFrame
df_val_coastal.shape

# Selects columns for model training including contaminant columns and the target variable 'Water quality' for the dataset from 2012 to 2021
df_train_coastal = df_train_coastal.iloc[:, list(range(6, 14)) + [30]]
df_train_coastal.head(5)

# Selects columns for model training including contaminant columns and the target variable 'Water quality' for the dataset of 2022
df_val_coastal = df_val_coastal.iloc[:, list(range(6, 14)) + [30]]
df_val_coastal.head(5)

"""Separation of the dependent variable (y) from the independent variables (X)"""

# Separates features (X_train_coastal) and target variable (y_train_coastal) for model training
X_train_coastal = df_train_coastal.drop(columns=['Water quality'])
y_train_coastal = df_train_coastal['Water quality']

# Separates features (X_val_coastal) and target variable (y_val_coastal) for validation
X_val_coastal = df_val_coastal.drop(columns=['Water quality'])
y_val_coastal = df_val_coastal['Water quality']

# Calculate the count of classes present in the 'Water quality' column
conteo_clases = df_train_coastal['Water quality'].value_counts()
print(conteo_clases)

"""Split data into training and test set"""

# Split the data into training and testing sets for model training
X_train_ub_coa, X_test_ub_coa, y_train_ub_coa, y_test_ub_coa = train_test_split(X_train_coastal, y_train_coastal, test_size=0.2, random_state=42)

X_train_ub_coa.shape

X_test_ub_coa.shape

# Guardar el conjunto de entrenamiento en un archivo Excel
X_train_ub_coa.to_excel("train_data_ub_coa.xlsx", index=False)
y_train_ub_coa.to_excel("train_labels_data_ub_coa.xlsx", index=False)

# Guardar el conjunto de prueba en un archivo Excel
X_test_ub_coa.to_excel("test_data_ub_coa.xlsx", index=False)
y_test_ub_coa.to_excel("test_labels_data_ub_coa.xlsx", index=False)

"""Feature Standardization for Coastal Dataset using StandardScaler"""

# Create a StandardScaler object
scaler_coa = StandardScaler()

# Fit and transform the training data to standardize features
X_train_ub_coa = scaler_coa.fit_transform(X_train_ub_coa)

# Transform the test data using the same scaler to maintain consistency in feature scaling
X_test_ub_coa = scaler_coa.transform(X_test_ub_coa)

"""##Unbalanced

###XGBOOST

Hyperparameter Grid for XGBoost Model
"""

# Define a dictionary of hyperparameters for tuning a XGBoost model
parameters = {
    'learning_rate': [.01, 0.1, 0.2],
    'max_depth': [10, 30, 50],
    'n_estimators': [100, 200, 300]
}

"""Create a Decision XGBoost model"""

# Initialize XGBoost classifier for coastal model
model_ub_coa_xgb = XGBClassifier()

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_ub_coa_xgb = GridSearchCV(model_ub_coa_xgb, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_ub_coa_xgb.fit(X_train_ub_coa, y_train_ub_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_ub_coa_xgb = grid_search_ub_coa_xgb.best_estimator_
print(best_model_ub_coa_xgb)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_ub_coa_xgb = grid_search_ub_coa_xgb.best_params_
print(best_params_ub_coa_xgb)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_ub_coa_xgb = grid_search_ub_coa_xgb.best_score_
print(best_score_ub_coa_xgb)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_ub_coa_xgb = best_model_ub_coa_xgb.predict(X_train_ub_coa)

# Evaluation metrics on the training set
accuracy_train_ub_coa_xgb = accuracy_score(y_train_ub_coa, y_pred_train_ub_coa_xgb)
precision_train_ub_coa_xgb = precision_score(y_train_ub_coa, y_pred_train_ub_coa_xgb, average='weighted')
# Calculate precision for each class
precision_x_class_train_ub_coa_xgb = precision_score(y_train_ub_coa, y_pred_train_ub_coa_xgb, average=None)
recall_train_ub_coa_xgb = recall_score(y_train_ub_coa, y_pred_train_ub_coa_xgb, average='weighted')
# Calculate recall for each class
recall_x_class_train_ub_coa_xgb = recall_score(y_train_ub_coa, y_pred_train_ub_coa_xgb, average=None)
f1_score_train_ub_coa_xgb = f1_score(y_train_ub_coa, y_pred_train_ub_coa_xgb, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_ub_coa_xgb = f1_score(y_train_ub_coa, y_pred_train_ub_coa_xgb, average=None)
jaccard_train_ub_coa_xgb = jaccard_score(y_train_ub_coa, y_pred_train_ub_coa_xgb, average='weighted')
confusion_train_ub_coa_xgb = confusion_matrix(y_train_ub_coa, y_pred_train_ub_coa_xgb)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_ub_coa_xgb)
print("Precision: ", precision_train_ub_coa_xgb)
print("Precision per class:" , precision_x_class_train_ub_coa_xgb )
print("Recall: ", recall_train_ub_coa_xgb)
print("Recall per class:" , recall_x_class_train_ub_coa_xgb )
print("F1 Score: ", f1_score_train_ub_coa_xgb)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_ub_coa_xgb):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_ub_coa_xgb )
print("Confusion Matrix: ")
print(confusion_train_ub_coa_xgb)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_ub_coa_xgb = best_model_ub_coa_xgb.predict(X_test_ub_coa)

# Evaluation metrics on the testing set
accuracy_test_ub_coa_xgb = accuracy_score(y_test_ub_coa, y_pred_test_ub_coa_xgb)
precision_test_ub_coa_xgb = precision_score(y_test_ub_coa, y_pred_test_ub_coa_xgb, average='weighted')
# Calculate precision for each class
precision_x_class_test_ub_coa_xgb = precision_score(y_test_ub_coa, y_pred_test_ub_coa_xgb, average=None)
recall_test_ub_coa_xgb = recall_score(y_test_ub_coa, y_pred_test_ub_coa_xgb, average='weighted')
# Calculate recall for each class
recall_x_class_test_ub_coa_xgb = recall_score(y_test_ub_coa, y_pred_test_ub_coa_xgb, average=None)
f1_score_test_ub_coa_xgb = f1_score(y_test_ub_coa, y_pred_test_ub_coa_xgb, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_ub_coa_xgb = f1_score(y_test_ub_coa, y_pred_test_ub_coa_xgb, average=None)
jaccard_test_ub_coa_xgb = jaccard_score(y_test_ub_coa, y_pred_test_ub_coa_xgb, average='weighted')
confusion_test_ub_coa_xgb = confusion_matrix(y_test_ub_coa, y_pred_test_ub_coa_xgb)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_ub_coa_xgb)
print("Precision: ", precision_test_ub_coa_xgb)
print("Precision per class:" , precision_x_class_test_ub_coa_xgb )
print("Recall: ", recall_test_ub_coa_xgb)
print("Recall per class:" , recall_x_class_test_ub_coa_xgb )
print("F1 Score: ", f1_score_test_ub_coa_xgb)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_ub_coa_xgb):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_ub_coa_xgb )
print("Confusion Matrix: ")
print(confusion_test_ub_coa_xgb)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_ub_coa_xgb = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained xgboost model
y_pred_val_ub_coa_xgb = best_model_ub_coa_xgb.predict(X_val_ub_coa_xgb)

# Evaluation metrics on the validation set
accuracy_val_ub_coa_xgb = accuracy_score(y_val_coastal, y_pred_val_ub_coa_xgb)
precision_val_ub_coa_xgb = precision_score(y_val_coastal, y_pred_val_ub_coa_xgb, average='weighted')
# Calculate precision for each class
precision_x_class_val_ub_coa_xgb = precision_score(y_val_coastal, y_pred_val_ub_coa_xgb, average=None)
recall_val_ub_coa_xgb = recall_score(y_val_coastal, y_pred_val_ub_coa_xgb, average='weighted')
# Calculate recall for each class
recall_x_class_val_ub_coa_xgb = recall_score(y_val_coastal, y_pred_val_ub_coa_xgb, average=None)
f1_score_val_ub_coa_xgb = f1_score(y_val_coastal, y_pred_val_ub_coa_xgb, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_ub_coa_xgb = f1_score(y_val_coastal, y_pred_val_ub_coa_xgb, average=None)
jaccard_val_ub_coa_xgb = jaccard_score(y_val_coastal, y_pred_val_ub_coa_xgb, average='weighted')
confusion_val_ub_coa_xgb = confusion_matrix(y_val_coastal, y_pred_val_ub_coa_xgb)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_ub_coa_xgb)
print("Precision: ", precision_val_ub_coa_xgb)
print("Precision per class:" , precision_x_class_val_ub_coa_xgb )
print("Recall: ", recall_val_ub_coa_xgb)
print("Recall per class:" , recall_x_class_val_ub_coa_xgb )
print("F1 Score: ", f1_score_val_ub_coa_xgb)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_ub_coa_xgb):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_ub_coa_xgb )
print("Confusion Matrix: ")
print(confusion_val_ub_coa_xgb)

# Save the trained XGBoost model to a file
with open('best_model_ub_coa_xgb.pkl', 'wb') as model_file:
    pickle.dump(best_model_ub_coa_xgb, model_file)

"""###SVM

Hyperparameter Grid for SVM Model
"""

# Define a dictionary of hyperparameters for tuning a SVM model
parameters = {
    'C': [0.1, 1, 10],
    'kernel': ['linear', 'rbf', 'poly'],
    'gamma': [0.1, 1, 'scale', 'auto'],
}

"""Create a Decision SVM model"""

#Create a Decision SVM model
model_ub_coa_svm = SVC()

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_ub_coa_svm = GridSearchCV(model_ub_coa_svm, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_ub_coa_svm.fit(X_train_ub_coa, y_train_ub_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_ub_coa_svm = grid_search_ub_coa_svm.best_estimator_
print(best_model_ub_coa_svm)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_ub_coa_svm = grid_search_ub_coa_svm.best_params_
print(best_params_ub_coa_svm)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_ub_coa_svm = grid_search_ub_coa_svm.best_score_
print(best_score_ub_coa_svm)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_ub_coa_svm = best_model_ub_coa_svm.predict(X_train_ub_coa)

# Evaluation metrics on the training set
accuracy_train_ub_coa_svm = accuracy_score(y_train_ub_coa, y_pred_train_ub_coa_svm)
precision_train_ub_coa_svm = precision_score(y_train_ub_coa, y_pred_train_ub_coa_svm, average='weighted')
# Calculate precision for each class
precision_x_class_train_ub_coa_svm = precision_score(y_train_ub_coa, y_pred_train_ub_coa_svm, average=None)
recall_train_ub_coa_svm = recall_score(y_train_ub_coa, y_pred_train_ub_coa_svm, average='weighted')
# Calculate recall for each class
recall_x_class_train_ub_coa_svm = recall_score(y_train_ub_coa, y_pred_train_ub_coa_svm, average=None)
f1_score_train_ub_coa_svm = f1_score(y_train_ub_coa, y_pred_train_ub_coa_svm, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_ub_coa_svm = f1_score(y_train_ub_coa, y_pred_train_ub_coa_svm, average=None)
jaccard_train_ub_coa_svm = jaccard_score(y_train_ub_coa, y_pred_train_ub_coa_svm, average='weighted')
confusion_train_ub_coa_svm = confusion_matrix(y_train_ub_coa, y_pred_train_ub_coa_svm)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_ub_coa_svm)
print("Precision: ", precision_train_ub_coa_svm)
print("Precision per class:" , precision_x_class_train_ub_coa_svm )
print("Recall: ", recall_train_ub_coa_svm)
print("Recall per class:" , recall_x_class_train_ub_coa_svm )
print("F1 Score: ", f1_score_train_ub_coa_svm)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_ub_coa_svm):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_ub_coa_svm )
print("Confusion Matrix: ")
print(confusion_train_ub_coa_svm)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_ub_coa_svm = best_model_ub_coa_svm.predict(X_test_ub_coa)

# Evaluation metrics on the testing set
accuracy_test_ub_coa_svm = accuracy_score(y_test_ub_coa, y_pred_test_ub_coa_svm)
precision_test_ub_coa_svm = precision_score(y_test_ub_coa, y_pred_test_ub_coa_svm, average='weighted')
# Calculate precision for each class
precision_x_class_test_ub_coa_svm = precision_score(y_test_ub_coa, y_pred_test_ub_coa_svm, average=None)
recall_test_ub_coa_svm = recall_score(y_test_ub_coa, y_pred_test_ub_coa_svm, average='weighted')
# Calculate recall for each class
recall_x_class_test_ub_coa_svm = recall_score(y_test_ub_coa, y_pred_test_ub_coa_svm, average=None)
f1_score_test_ub_coa_svm = f1_score(y_test_ub_coa, y_pred_test_ub_coa_svm, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_ub_coa_svm = f1_score(y_test_ub_coa, y_pred_test_ub_coa_svm, average=None)
jaccard_test_ub_coa_svm = jaccard_score(y_test_ub_coa, y_pred_test_ub_coa_svm, average='weighted')
confusion_test_ub_coa_svm = confusion_matrix(y_test_ub_coa, y_pred_test_ub_coa_svm)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_ub_coa_svm)
print("Precision: ", precision_test_ub_coa_svm)
print("Precision per class:" , precision_x_class_test_ub_coa_svm )
print("Recall: ", recall_test_ub_coa_svm)
print("Recall per class:" , recall_x_class_test_ub_coa_svm )
print("F1 Score: ", f1_score_test_ub_coa_svm)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_ub_coa_svm):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_ub_coa_svm )
print("Confusion Matrix: ")
print(confusion_test_ub_coa_svm)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_ub_coa_svm = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained svm model
y_pred_val_ub_coa_svm = best_model_ub_coa_svm.predict(X_val_ub_coa_svm)

# Evaluation metrics on the validation set
accuracy_val_ub_coa_svm = accuracy_score(y_val_coastal, y_pred_val_ub_coa_svm)
precision_val_ub_coa_svm = precision_score(y_val_coastal, y_pred_val_ub_coa_svm, average='weighted')
# Calculate precision for each class
precision_x_class_val_ub_coa_svm = precision_score(y_val_coastal, y_pred_val_ub_coa_svm, average=None)
recall_val_ub_coa_svm = recall_score(y_val_coastal, y_pred_val_ub_coa_svm, average='weighted')
# Calculate recall for each class
recall_x_class_val_ub_coa_svm = recall_score(y_val_coastal, y_pred_val_ub_coa_svm, average=None)
f1_score_val_ub_coa_svm = f1_score(y_val_coastal, y_pred_val_ub_coa_svm, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_ub_coa_svm = f1_score(y_val_coastal, y_pred_val_ub_coa_svm, average=None)
jaccard_val_ub_coa_svm = jaccard_score(y_val_coastal, y_pred_val_ub_coa_svm, average='weighted')
confusion_val_ub_coa_svm = confusion_matrix(y_val_coastal, y_pred_val_ub_coa_svm)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_ub_coa_svm)
print("Precision: ", precision_val_ub_coa_svm)
print("Precision per class:" , precision_x_class_val_ub_coa_svm )
print("Recall: ", recall_val_ub_coa_svm)
print("Recall per class:" , recall_x_class_val_ub_coa_svm )
print("F1 Score: ", f1_score_val_ub_coa_svm)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_ub_coa_svm):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_ub_coa_svm )
print("Confusion Matrix: ")
print(confusion_val_ub_coa_svm)

# Save the trained SVM model to a file
with open('best_model_ub_coa_svm.pkl', 'wb') as model_file:
    pickle.dump(best_model_ub_coa_svm, model_file)

"""###KNN

Hyperparameter Grid for KNN Model
"""

# Define a dictionary of hyperparameters for tuning a KNN model
parameters = {
    'n_neighbors': [3, 5, 7, 9],  # Número de vecinos
    'weights': ['uniform', 'distance'],  # Tipo de ponderación
    'p': [1, 2]  # Parámetro para la distancia (1 para la distancia de Manhattan, 2 para la Euclidiana)
}

"""Create a Decision KNN model"""

model_ub_coa_knn = KNeighborsClassifier()

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_ub_coa_knn = GridSearchCV(model_ub_coa_knn, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_ub_coa_knn.fit(X_train_ub_coa, y_train_ub_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_ub_coa_knn = grid_search_ub_coa_knn.best_estimator_
print(best_model_ub_coa_knn)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_ub_coa_knn = grid_search_ub_coa_knn.best_params_
print(best_params_ub_coa_knn)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_ub_coa_knn = grid_search_ub_coa_knn.best_score_
print(best_score_ub_coa_knn)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_ub_coa_knn = best_model_ub_coa_knn.predict(X_train_ub_coa)

# Evaluation metrics on the training set
accuracy_train_ub_coa_knn = accuracy_score(y_train_ub_coa, y_pred_train_ub_coa_knn)
precision_train_ub_coa_knn = precision_score(y_train_ub_coa, y_pred_train_ub_coa_knn, average='weighted')
# Calculate precision for each class
precision_x_class_train_ub_coa_knn = precision_score(y_train_ub_coa, y_pred_train_ub_coa_knn, average=None)
recall_train_ub_coa_knn = recall_score(y_train_ub_coa, y_pred_train_ub_coa_knn, average='weighted')
# Calculate recall for each class
recall_x_class_train_ub_coa_knn = recall_score(y_train_ub_coa, y_pred_train_ub_coa_knn, average=None)
f1_score_train_ub_coa_knn = f1_score(y_train_ub_coa, y_pred_train_ub_coa_knn, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_ub_coa_knn = f1_score(y_train_ub_coa, y_pred_train_ub_coa_knn, average=None)
jaccard_train_ub_coa_knn = jaccard_score(y_train_ub_coa, y_pred_train_ub_coa_knn, average='weighted')
confusion_train_ub_coa_knn = confusion_matrix(y_train_ub_coa, y_pred_train_ub_coa_knn)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_ub_coa_knn)
print("Precision: ", precision_train_ub_coa_knn)
print("Precision per class:" , precision_x_class_train_ub_coa_knn )
print("Recall: ", recall_train_ub_coa_knn)
print("Recall per class:" , recall_x_class_train_ub_coa_knn )
print("F1 Score: ", f1_score_train_ub_coa_knn)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_ub_coa_knn):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_ub_coa_knn )
print("Confusion Matrix: ")
print(confusion_train_ub_coa_knn)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_ub_coa_knn = best_model_ub_coa_knn.predict(X_test_ub_coa)

# Evaluation metrics on the testing set
accuracy_test_ub_coa_knn = accuracy_score(y_test_ub_coa, y_pred_test_ub_coa_knn)
precision_test_ub_coa_knn = precision_score(y_test_ub_coa, y_pred_test_ub_coa_knn, average='weighted')
# Calculate precision for each class
precision_x_class_test_ub_coa_knn = precision_score(y_test_ub_coa, y_pred_test_ub_coa_knn, average=None)
recall_test_ub_coa_knn = recall_score(y_test_ub_coa, y_pred_test_ub_coa_knn, average='weighted')
# Calculate recall for each class
recall_x_class_test_ub_coa_knn = recall_score(y_test_ub_coa, y_pred_test_ub_coa_knn, average=None)
f1_score_test_ub_coa_knn = f1_score(y_test_ub_coa, y_pred_test_ub_coa_knn, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_ub_coa_knn = f1_score(y_test_ub_coa, y_pred_test_ub_coa_knn, average=None)
jaccard_test_ub_coa_knn = jaccard_score(y_test_ub_coa, y_pred_test_ub_coa_knn, average='weighted')
confusion_test_ub_coa_knn = confusion_matrix(y_test_ub_coa, y_pred_test_ub_coa_knn)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_ub_coa_knn)
print("Precision: ", precision_test_ub_coa_knn)
print("Precision per class:" , precision_x_class_test_ub_coa_knn )
print("Recall: ", recall_test_ub_coa_knn)
print("Recall per class:" , recall_x_class_test_ub_coa_knn )
print("F1 Score: ", f1_score_test_ub_coa_knn)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_ub_coa_knn):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_ub_coa_knn )
print("Confusion Matrix: ")
print(confusion_test_ub_coa_knn)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_ub_coa_knn = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained knn model
y_pred_val_ub_coa_knn = best_model_ub_coa_knn.predict(X_val_ub_coa_knn)

# Evaluation metrics on the validation set
accuracy_val_ub_coa_knn = accuracy_score(y_val_coastal, y_pred_val_ub_coa_knn)
precision_val_ub_coa_knn = precision_score(y_val_coastal, y_pred_val_ub_coa_knn, average='weighted')
# Calculate precision for each class
precision_x_class_val_ub_coa_knn = precision_score(y_val_coastal, y_pred_val_ub_coa_knn, average=None)
recall_val_ub_coa_knn = recall_score(y_val_coastal, y_pred_val_ub_coa_knn, average='weighted')
# Calculate recall for each class
recall_x_class_val_ub_coa_knn = recall_score(y_val_coastal, y_pred_val_ub_coa_knn, average=None)
f1_score_val_ub_coa_knn = f1_score(y_val_coastal, y_pred_val_ub_coa_knn, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_ub_coa_knn = f1_score(y_val_coastal, y_pred_val_ub_coa_knn, average=None)
jaccard_val_ub_coa_knn = jaccard_score(y_val_coastal, y_pred_val_ub_coa_knn, average='weighted')
confusion_val_ub_coa_knn = confusion_matrix(y_val_coastal, y_pred_val_ub_coa_knn)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_ub_coa_knn)
print("Precision: ", precision_val_ub_coa_knn)
print("Precision per class:" , precision_x_class_val_ub_coa_knn )
print("Recall: ", recall_val_ub_coa_knn)
print("Recall per class:" , recall_x_class_val_ub_coa_knn )
print("F1 Score: ", f1_score_val_ub_coa_knn)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_ub_coa_knn):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_ub_coa_knn )
print("Confusion Matrix: ")
print(confusion_val_ub_coa_knn)

# Save the trained KNN model to a file
with open('best_model_ub_coa_knn.pkl', 'wb') as model_file:
    pickle.dump(best_model_ub_coa_knn, model_file)

"""###DT

Hyperparameter Grid for DT Model
"""

# Define a dictionary of hyperparameters for tuning a DT model
parameters = {
    'criterion': ['gini', 'entropy'],  # Criterio para la división de nodos
    'max_depth': [None, 10, 20, 30, 40, 50],  # Profundidad máxima del árbol
    'min_samples_split': [2, 5, 10],  # Número mínimo de muestras para dividir un nodo
    'min_samples_leaf': [1, 2, 4]  # Número mínimo de muestras requeridas en una hoja
}

"""Create a Decision DT model"""

model_ub_coa_dt = DecisionTreeClassifier()

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_ub_coa_dt = GridSearchCV(model_ub_coa_dt, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_ub_coa_dt.fit(X_train_ub_coa, y_train_ub_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_ub_coa_dt = grid_search_ub_coa_dt.best_estimator_
print(best_model_ub_coa_dt)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_ub_coa_dt = grid_search_ub_coa_dt.best_params_
print(best_params_ub_coa_dt)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_ub_coa_dt = grid_search_ub_coa_dt.best_score_
print(best_score_ub_coa_dt)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_ub_coa_dt = best_model_ub_coa_dt.predict(X_train_ub_coa)

# Evaluation metrics on the training set
accuracy_train_ub_coa_dt = accuracy_score(y_train_ub_coa, y_pred_train_ub_coa_dt)
precision_train_ub_coa_dt = precision_score(y_train_ub_coa, y_pred_train_ub_coa_dt, average='weighted')
# Calculate precision for each class
precision_x_class_train_ub_coa_dt = precision_score(y_train_ub_coa, y_pred_train_ub_coa_dt, average=None)
recall_train_ub_coa_dt = recall_score(y_train_ub_coa, y_pred_train_ub_coa_dt, average='weighted')
# Calculate recall for each class
recall_x_class_train_ub_coa_dt = recall_score(y_train_ub_coa, y_pred_train_ub_coa_dt, average=None)
f1_score_train_ub_coa_dt = f1_score(y_train_ub_coa, y_pred_train_ub_coa_dt, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_ub_coa_dt = f1_score(y_train_ub_coa, y_pred_train_ub_coa_dt, average=None)
jaccard_train_ub_coa_dt = jaccard_score(y_train_ub_coa, y_pred_train_ub_coa_dt, average='weighted')
confusion_train_ub_coa_dt = confusion_matrix(y_train_ub_coa, y_pred_train_ub_coa_dt)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_ub_coa_dt)
print("Precision: ", precision_train_ub_coa_dt)
print("Precision per class:" , precision_x_class_train_ub_coa_dt )
print("Recall: ", recall_train_ub_coa_dt)
print("Recall per class:" , recall_x_class_train_ub_coa_dt )
print("F1 Score: ", f1_score_train_ub_coa_dt)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_ub_coa_dt):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_ub_coa_dt )
print("Confusion Matrix: ")
print(confusion_train_ub_coa_dt)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_ub_coa_dt = best_model_ub_coa_dt.predict(X_test_ub_coa)

# Evaluation metrics on the testing set
accuracy_test_ub_coa_dt = accuracy_score(y_test_ub_coa, y_pred_test_ub_coa_dt)
precision_test_ub_coa_dt = precision_score(y_test_ub_coa, y_pred_test_ub_coa_dt, average='weighted')
# Calculate precision for each class
precision_x_class_test_ub_coa_dt = precision_score(y_test_ub_coa, y_pred_test_ub_coa_dt, average=None)
recall_test_ub_coa_dt = recall_score(y_test_ub_coa, y_pred_test_ub_coa_dt, average='weighted')
# Calculate recall for each class
recall_x_class_test_ub_coa_dt = recall_score(y_test_ub_coa, y_pred_test_ub_coa_dt, average=None)
f1_score_test_ub_coa_dt = f1_score(y_test_ub_coa, y_pred_test_ub_coa_dt, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_ub_coa_dt = f1_score(y_test_ub_coa, y_pred_test_ub_coa_dt, average=None)
jaccard_test_ub_coa_dt = jaccard_score(y_test_ub_coa, y_pred_test_ub_coa_dt, average='weighted')
confusion_test_ub_coa_dt = confusion_matrix(y_test_ub_coa, y_pred_test_ub_coa_dt)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_ub_coa_dt)
print("Precision: ", precision_test_ub_coa_dt)
print("Precision per class:" , precision_x_class_test_ub_coa_dt )
print("Recall: ", recall_test_ub_coa_dt)
print("Recall per class:" , recall_x_class_test_ub_coa_dt )
print("F1 Score: ", f1_score_test_ub_coa_dt)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_ub_coa_dt):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_ub_coa_dt )
print("Confusion Matrix: ")
print(confusion_test_ub_coa_dt)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_ub_coa_dt = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained dt model
y_pred_val_ub_coa_dt = best_model_ub_coa_dt.predict(X_val_ub_coa_dt)

# Evaluation metrics on the validation set
accuracy_val_ub_coa_dt = accuracy_score(y_val_coastal, y_pred_val_ub_coa_dt)
precision_val_ub_coa_dt = precision_score(y_val_coastal, y_pred_val_ub_coa_dt, average='weighted')
# Calculate precision for each class
precision_x_class_val_ub_coa_dt = precision_score(y_val_coastal, y_pred_val_ub_coa_dt, average=None)
recall_val_ub_coa_dt = recall_score(y_val_coastal, y_pred_val_ub_coa_dt, average='weighted')
# Calculate recall for each class
recall_x_class_val_ub_coa_dt = recall_score(y_val_coastal, y_pred_val_ub_coa_dt, average=None)
f1_score_val_ub_coa_dt = f1_score(y_val_coastal, y_pred_val_ub_coa_dt, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_ub_coa_dt = f1_score(y_val_coastal, y_pred_val_ub_coa_dt, average=None)
jaccard_val_ub_coa_dt = jaccard_score(y_val_coastal, y_pred_val_ub_coa_dt, average='weighted')
confusion_val_ub_coa_dt = confusion_matrix(y_val_coastal, y_pred_val_ub_coa_dt)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_ub_coa_dt)
print("Precision: ", precision_val_ub_coa_dt)
print("Precision per class:" , precision_x_class_val_ub_coa_dt )
print("Recall: ", recall_val_ub_coa_dt)
print("Recall per class:" , recall_x_class_val_ub_coa_dt )
print("F1 Score: ", f1_score_val_ub_coa_dt)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_ub_coa_dt):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_ub_coa_dt )
print("Confusion Matrix: ")
print(confusion_val_ub_coa_dt)

# Save the trained DT model to a file
with open('best_model_ub_coa_dt.pkl', 'wb') as model_file:
    pickle.dump(best_model_ub_coa_dt, model_file)

"""###MLR

Hyperparameter Grid for MLR Model
"""

# Define a dictionary of hyperparameters for tuning a MLR model
parameters = {
    'C': [0.001, 0.01, 0.1, 1, 10, 100],  # Parámetro de regularización
    'solver': ['newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga']  # Método de optimización
}

"""Create a Decision MLR model"""

model_ub_coa_mlr = LogisticRegression(max_iter=1000)  # Usamos max_iter para evitar advertencias

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_ub_coa_mlr = GridSearchCV(model_ub_coa_mlr, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_ub_coa_mlr.fit(X_train_ub_coa, y_train_ub_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_ub_coa_mlr = grid_search_ub_coa_mlr.best_estimator_
print(best_model_ub_coa_mlr)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_ub_coa_mlr = grid_search_ub_coa_mlr.best_params_
print(best_params_ub_coa_mlr)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_ub_coa_mlr = grid_search_ub_coa_mlr.best_score_
print(best_score_ub_coa_mlr)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_ub_coa_mlr = best_model_ub_coa_mlr.predict(X_train_ub_coa)

# Evaluation metrics on the training set
accuracy_train_ub_coa_mlr = accuracy_score(y_train_ub_coa, y_pred_train_ub_coa_mlr)
precision_train_ub_coa_mlr = precision_score(y_train_ub_coa, y_pred_train_ub_coa_mlr, average='weighted')
# Calculate precision for each class
precision_x_class_train_ub_coa_mlr = precision_score(y_train_ub_coa, y_pred_train_ub_coa_mlr, average=None)
recall_train_ub_coa_mlr = recall_score(y_train_ub_coa, y_pred_train_ub_coa_mlr, average='weighted')
# Calculate recall for each class
recall_x_class_train_ub_coa_mlr = recall_score(y_train_ub_coa, y_pred_train_ub_coa_mlr, average=None)
f1_score_train_ub_coa_mlr = f1_score(y_train_ub_coa, y_pred_train_ub_coa_mlr, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_ub_coa_mlr = f1_score(y_train_ub_coa, y_pred_train_ub_coa_mlr, average=None)
jaccard_train_ub_coa_mlr = jaccard_score(y_train_ub_coa, y_pred_train_ub_coa_mlr, average='weighted')
confusion_train_ub_coa_mlr = confusion_matrix(y_train_ub_coa, y_pred_train_ub_coa_mlr)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_ub_coa_mlr)
print("Precision: ", precision_train_ub_coa_mlr)
print("Precision per class:" , precision_x_class_train_ub_coa_mlr )
print("Recall: ", recall_train_ub_coa_mlr)
print("Recall per class:" , recall_x_class_train_ub_coa_mlr )
print("F1 Score: ", f1_score_train_ub_coa_mlr)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_ub_coa_mlr):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_ub_coa_mlr )
print("Confusion Matrix: ")
print(confusion_train_ub_coa_mlr)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_ub_coa_mlr = best_model_ub_coa_mlr.predict(X_test_ub_coa)

# Evaluation metrics on the testing set
accuracy_test_ub_coa_mlr = accuracy_score(y_test_ub_coa, y_pred_test_ub_coa_mlr)
precision_test_ub_coa_mlr = precision_score(y_test_ub_coa, y_pred_test_ub_coa_mlr, average='weighted')
# Calculate precision for each class
precision_x_class_test_ub_coa_mlr = precision_score(y_test_ub_coa, y_pred_test_ub_coa_mlr, average=None)
recall_test_ub_coa_mlr = recall_score(y_test_ub_coa, y_pred_test_ub_coa_mlr, average='weighted')
# Calculate recall for each class
recall_x_class_test_ub_coa_mlr = recall_score(y_test_ub_coa, y_pred_test_ub_coa_mlr, average=None)
f1_score_test_ub_coa_mlr = f1_score(y_test_ub_coa, y_pred_test_ub_coa_mlr, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_ub_coa_mlr = f1_score(y_test_ub_coa, y_pred_test_ub_coa_mlr, average=None)
jaccard_test_ub_coa_mlr = jaccard_score(y_test_ub_coa, y_pred_test_ub_coa_mlr, average='weighted')
confusion_test_ub_coa_mlr = confusion_matrix(y_test_ub_coa, y_pred_test_ub_coa_mlr)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_ub_coa_mlr)
print("Precision: ", precision_test_ub_coa_mlr)
print("Precision per class:" , precision_x_class_test_ub_coa_mlr )
print("Recall: ", recall_test_ub_coa_mlr)
print("Recall per class:" , recall_x_class_test_ub_coa_mlr )
print("F1 Score: ", f1_score_test_ub_coa_mlr)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_ub_coa_mlr):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_ub_coa_mlr )
print("Confusion Matrix: ")
print(confusion_test_ub_coa_mlr)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_ub_coa_mlr = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained mlr model
y_pred_val_ub_coa_mlr = best_model_ub_coa_mlr.predict(X_val_ub_coa_mlr)

# Evaluation metrics on the validation set
accuracy_val_ub_coa_mlr = accuracy_score(y_val_coastal, y_pred_val_ub_coa_mlr)
precision_val_ub_coa_mlr = precision_score(y_val_coastal, y_pred_val_ub_coa_mlr, average='weighted')
# Calculate precision for each class
precision_x_class_val_ub_coa_mlr = precision_score(y_val_coastal, y_pred_val_ub_coa_mlr, average=None)
recall_val_ub_coa_mlr = recall_score(y_val_coastal, y_pred_val_ub_coa_mlr, average='weighted')
# Calculate recall for each class
recall_x_class_val_ub_coa_mlr = recall_score(y_val_coastal, y_pred_val_ub_coa_mlr, average=None)
f1_score_val_ub_coa_mlr = f1_score(y_val_coastal, y_pred_val_ub_coa_mlr, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_ub_coa_mlr = f1_score(y_val_coastal, y_pred_val_ub_coa_mlr, average=None)
jaccard_val_ub_coa_mlr = jaccard_score(y_val_coastal, y_pred_val_ub_coa_mlr, average='weighted')
confusion_val_ub_coa_mlr = confusion_matrix(y_val_coastal, y_pred_val_ub_coa_mlr)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_ub_coa_mlr)
print("Precision: ", precision_val_ub_coa_mlr)
print("Precision per class:" , precision_x_class_val_ub_coa_mlr )
print("Recall: ", recall_val_ub_coa_mlr)
print("Recall per class:" , recall_x_class_val_ub_coa_mlr )
print("F1 Score: ", f1_score_val_ub_coa_mlr)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_ub_coa_mlr):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_ub_coa_mlr )
print("Confusion Matrix: ")
print(confusion_val_ub_coa_mlr)

# Save the trained MLR model to a file
with open('best_model_ub_coa_mlr.pkl', 'wb') as model_file:
    pickle.dump(best_model_ub_coa_mlr, model_file)

"""##Balanced

Apply random subsampling
"""

print('Before class balancing: ', Counter(y_train_coastal))
print("")
rus = RandomUnderSampler(random_state=42)
X_train_b_coa, y_train_b_coa = rus.fit_resample(X_train_coastal, y_train_coastal)
print('After the balancing y:', Counter(y_train_b_coa))
print("")
print('After the balancing X:', Counter(X_train_b_coa))

"""Split data into training and test set"""

X_train_b_coa, X_test_b_coa, y_train_b_coa, y_test_b_coa = train_test_split(X_train_b_coa, y_train_b_coa, test_size=0.2, random_state=42)

X_train_b_coa.shape

X_test_b_coa.shape

# Guardar el conjunto de entrenamiento en un archivo Excel
X_train_b_coa.to_excel("train_data_b_coa.xlsx", index=False)
y_train_b_coa.to_excel("train_labels_data_b_coa.xlsx", index=False)

# Guardar el conjunto de prueba en un archivo Excel
X_test_b_coa.to_excel("test_data_b_coa.xlsx", index=False)
y_test_b_coa.to_excel("test_labels_data_b_coa.xlsx", index=False)

"""Feature Standardization for Coastal Dataset using StandardScaler"""

# Fit and transform the training data to standardize features
X_train_b_coa = scaler_coa.fit_transform(X_train_b_coa)

# Transform the test data using the same scaler to maintain consistency in feature scaling
X_test_b_coa = scaler_coa.transform(X_test_b_coa)

"""###XGBOOST

Hyperparameter Grid for XGBoost Model
"""

# Define a dictionary of hyperparameters for tuning a XGBoost model
parameters = {
    'learning_rate': [.01, 0.1, 0.2],
    'max_depth': [10, 30, 50],
    'n_estimators': [100, 200, 300]
}

"""Create a Decision XGBoost model"""

model_b_coa_xgb = XGBClassifier()

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_b_coa_xgb = GridSearchCV(model_b_coa_xgb, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_b_coa_xgb.fit(X_train_b_coa, y_train_b_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_b_coa_xgb = grid_search_b_coa_xgb.best_estimator_
print(best_model_b_coa_xgb)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_b_coa_xgb = grid_search_b_coa_xgb.best_params_
print(best_params_b_coa_xgb)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_b_coa_xgb = grid_search_b_coa_xgb.best_score_
print(best_score_b_coa_xgb)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_b_coa_xgb = best_model_b_coa_xgb.predict(X_train_b_coa)

# Evaluation metrics on the training set
accuracy_train_b_coa_xgb = accuracy_score(y_train_b_coa, y_pred_train_b_coa_xgb)
precision_train_b_coa_xgb = precision_score(y_train_b_coa, y_pred_train_b_coa_xgb, average='weighted')
# Calculate precision for each class
precision_x_class_train_b_coa_xgb = precision_score(y_train_b_coa, y_pred_train_b_coa_xgb, average=None)
recall_train_b_coa_xgb = recall_score(y_train_b_coa, y_pred_train_b_coa_xgb, average='weighted')
# Calculate recall for each class
recall_x_class_train_b_coa_xgb = recall_score(y_train_b_coa, y_pred_train_b_coa_xgb, average=None)
f1_score_train_b_coa_xgb = f1_score(y_train_b_coa, y_pred_train_b_coa_xgb, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_b_coa_xgb = f1_score(y_train_b_coa, y_pred_train_b_coa_xgb, average=None)
jaccard_train_b_coa_xgb = jaccard_score(y_train_b_coa, y_pred_train_b_coa_xgb, average='weighted')
confusion_train_b_coa_xgb = confusion_matrix(y_train_b_coa, y_pred_train_b_coa_xgb)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_b_coa_xgb)
print("Precision: ", precision_train_b_coa_xgb)
print("Precision per class:" , precision_x_class_train_b_coa_xgb )
print("Recall: ", recall_train_b_coa_xgb)
print("Recall per class:" , recall_x_class_train_b_coa_xgb )
print("F1 Score: ", f1_score_train_b_coa_xgb)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_b_coa_xgb):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_b_coa_xgb )
print("Confusion Matrix: ")
print(confusion_train_b_coa_xgb)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_b_coa_xgb = best_model_b_coa_xgb.predict(X_test_b_coa)

# Evaluation metrics on the testing set
accuracy_test_b_coa_xgb = accuracy_score(y_test_b_coa, y_pred_test_b_coa_xgb)
precision_test_b_coa_xgb = precision_score(y_test_b_coa, y_pred_test_b_coa_xgb, average='weighted')
# Calculate precision for each class
precision_x_class_test_b_coa_xgb = precision_score(y_test_b_coa, y_pred_test_b_coa_xgb, average=None)
recall_test_b_coa_xgb = recall_score(y_test_b_coa, y_pred_test_b_coa_xgb, average='weighted')
# Calculate recall for each class
recall_x_class_test_b_coa_xgb = recall_score(y_test_b_coa, y_pred_test_b_coa_xgb, average=None)
f1_score_test_b_coa_xgb = f1_score(y_test_b_coa, y_pred_test_b_coa_xgb, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_b_coa_xgb = f1_score(y_test_b_coa, y_pred_test_b_coa_xgb, average=None)
jaccard_test_b_coa_xgb = jaccard_score(y_test_b_coa, y_pred_test_b_coa_xgb, average='weighted')
confusion_test_b_coa_xgb = confusion_matrix(y_test_b_coa, y_pred_test_b_coa_xgb)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_b_coa_xgb)
print("Precision: ", precision_test_b_coa_xgb)
print("Precision per class:" , precision_x_class_test_b_coa_xgb )
print("Recall: ", recall_test_b_coa_xgb)
print("Recall per class:" , recall_x_class_test_b_coa_xgb )
print("F1 Score: ", f1_score_test_b_coa_xgb)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_b_coa_xgb):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_b_coa_xgb )
print("Confusion Matrix: ")
print(confusion_test_b_coa_xgb)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_b_coa_xgb = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained xgboost model
y_pred_val_b_coa_xgb = best_model_b_coa_xgb.predict(X_val_b_coa_xgb)

# Evaluation metrics on the validation set
accuracy_val_b_coa_xgb = accuracy_score(y_val_coastal, y_pred_val_b_coa_xgb)
precision_val_b_coa_xgb = precision_score(y_val_coastal, y_pred_val_b_coa_xgb, average='weighted')
# Calculate precision for each class
precision_x_class_val_b_coa_xgb = precision_score(y_val_coastal, y_pred_val_b_coa_xgb, average=None)
recall_val_b_coa_xgb = recall_score(y_val_coastal, y_pred_val_b_coa_xgb, average='weighted')
# Calculate recall for each class
recall_x_class_val_b_coa_xgb = recall_score(y_val_coastal, y_pred_val_b_coa_xgb, average=None)
f1_score_val_b_coa_xgb = f1_score(y_val_coastal, y_pred_val_b_coa_xgb, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_b_coa_xgb = f1_score(y_val_coastal, y_pred_val_b_coa_xgb, average=None)
jaccard_val_b_coa_xgb = jaccard_score(y_val_coastal, y_pred_val_b_coa_xgb, average='weighted')
confusion_val_b_coa_xgb = confusion_matrix(y_val_coastal, y_pred_val_b_coa_xgb)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_b_coa_xgb)
print("Precision: ", precision_val_b_coa_xgb)
print("Precision per class:" , precision_x_class_val_b_coa_xgb )
print("Recall: ", recall_val_b_coa_xgb)
print("Recall per class:" , recall_x_class_val_b_coa_xgb )
print("F1 Score: ", f1_score_val_b_coa_xgb)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_b_coa_xgb):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_b_coa_xgb )
print("Confusion Matrix: ")
print(confusion_val_b_coa_xgb)

# Save the trained XGBoost model to a file
with open('best_model_b_coa_xgb.pkl', 'wb') as model_file:
    pickle.dump(best_model_b_coa_xgb, model_file)

"""###SVM

Hyperparameter Grid for SVM Model
"""

# Define a dictionary of hyperparameters for tuning a SVM model
parameters = {
    'C': [0.1, 1, 10],
    'kernel': ['linear', 'rbf', 'poly'],
    'gamma': [0.1, 1, 'scale', 'auto'],
}

"""Create a Decision SVM model"""

#Create a Decision SVM model
model_b_coa_svm = SVC()

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_b_coa_svm = GridSearchCV(model_b_coa_svm, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_b_coa_svm.fit(X_train_b_coa, y_train_b_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_b_coa_svm = grid_search_b_coa_svm.best_estimator_
print(best_model_b_coa_svm)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_b_coa_svm = grid_search_b_coa_svm.best_params_
print(best_params_b_coa_svm)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_b_coa_svm = grid_search_b_coa_svm.best_score_
print(best_score_b_coa_svm)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_b_coa_svm = best_model_b_coa_svm.predict(X_train_b_coa)

# Evaluation metrics on the training set
accuracy_train_b_coa_svm = accuracy_score(y_train_b_coa, y_pred_train_b_coa_svm)
precision_train_b_coa_svm = precision_score(y_train_b_coa, y_pred_train_b_coa_svm, average='weighted')
# Calculate precision for each class
precision_x_class_train_b_coa_svm = precision_score(y_train_b_coa, y_pred_train_b_coa_svm, average=None)
recall_train_b_coa_svm = recall_score(y_train_b_coa, y_pred_train_b_coa_svm, average='weighted')
# Calculate recall for each class
recall_x_class_train_b_coa_svm = recall_score(y_train_b_coa, y_pred_train_b_coa_svm, average=None)
f1_score_train_b_coa_svm = f1_score(y_train_b_coa, y_pred_train_b_coa_svm, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_b_coa_svm = f1_score(y_train_b_coa, y_pred_train_b_coa_svm, average=None)
jaccard_train_b_coa_svm = jaccard_score(y_train_b_coa, y_pred_train_b_coa_svm, average='weighted')
confusion_train_b_coa_svm = confusion_matrix(y_train_b_coa, y_pred_train_b_coa_svm)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_b_coa_svm)
print("Precision: ", precision_train_b_coa_svm)
print("Precision per class:" , precision_x_class_train_b_coa_svm )
print("Recall: ", recall_train_b_coa_svm)
print("Recall per class:" , recall_x_class_train_b_coa_svm )
print("F1 Score: ", f1_score_train_b_coa_svm)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_b_coa_svm):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_b_coa_svm )
print("Confusion Matrix: ")
print(confusion_train_b_coa_svm)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_b_coa_svm = best_model_b_coa_svm.predict(X_test_b_coa)

# Evaluation metrics on the testing set
accuracy_test_b_coa_svm = accuracy_score(y_test_b_coa, y_pred_test_b_coa_svm)
precision_test_b_coa_svm = precision_score(y_test_b_coa, y_pred_test_b_coa_svm, average='weighted')
# Calculate precision for each class
precision_x_class_test_b_coa_svm = precision_score(y_test_b_coa, y_pred_test_b_coa_svm, average=None)
recall_test_b_coa_svm = recall_score(y_test_b_coa, y_pred_test_b_coa_svm, average='weighted')
# Calculate recall for each class
recall_x_class_test_b_coa_svm = recall_score(y_test_b_coa, y_pred_test_b_coa_svm, average=None)
f1_score_test_b_coa_svm = f1_score(y_test_b_coa, y_pred_test_b_coa_svm, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_b_coa_svm = f1_score(y_test_b_coa, y_pred_test_b_coa_svm, average=None)
jaccard_test_b_coa_svm = jaccard_score(y_test_b_coa, y_pred_test_b_coa_svm, average='weighted')
confusion_test_b_coa_svm = confusion_matrix(y_test_b_coa, y_pred_test_b_coa_svm)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_b_coa_svm)
print("Precision: ", precision_test_b_coa_svm)
print("Precision per class:" , precision_x_class_test_b_coa_svm )
print("Recall: ", recall_test_b_coa_svm)
print("Recall per class:" , recall_x_class_test_b_coa_svm )
print("F1 Score: ", f1_score_test_b_coa_svm)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_b_coa_svm):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_b_coa_svm )
print("Confusion Matrix: ")
print(confusion_test_b_coa_svm)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_b_coa_svm = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained svm model
y_pred_val_b_coa_svm = best_model_b_coa_svm.predict(X_val_b_coa_svm)

# Evaluation metrics on the validation set
accuracy_val_b_coa_svm = accuracy_score(y_val_coastal, y_pred_val_b_coa_svm)
precision_val_b_coa_svm = precision_score(y_val_coastal, y_pred_val_b_coa_svm, average='weighted')
# Calculate precision for each class
precision_x_class_val_b_coa_svm = precision_score(y_val_coastal, y_pred_val_b_coa_svm, average=None)
recall_val_b_coa_svm = recall_score(y_val_coastal, y_pred_val_b_coa_svm, average='weighted')
# Calculate recall for each class
recall_x_class_val_b_coa_svm = recall_score(y_val_coastal, y_pred_val_b_coa_svm, average=None)
f1_score_val_b_coa_svm = f1_score(y_val_coastal, y_pred_val_b_coa_svm, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_b_coa_svm = f1_score(y_val_coastal, y_pred_val_b_coa_svm, average=None)
jaccard_val_b_coa_svm = jaccard_score(y_val_coastal, y_pred_val_b_coa_svm, average='weighted')
confusion_val_b_coa_svm = confusion_matrix(y_val_coastal, y_pred_val_b_coa_svm)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_b_coa_svm)
print("Precision: ", precision_val_b_coa_svm)
print("Precision per class:" , precision_x_class_val_b_coa_svm )
print("Recall: ", recall_val_b_coa_svm)
print("Recall per class:" , recall_x_class_val_b_coa_svm )
print("F1 Score: ", f1_score_val_b_coa_svm)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_b_coa_svm):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_b_coa_svm )
print("Confusion Matrix: ")
print(confusion_val_b_coa_svm)

# Save the trained SVM model to a file
with open('best_model_b_coa_svm.pkl', 'wb') as model_file:
    pickle.dump(best_model_b_coa_svm, model_file)

"""###KNN

Hyperparameter Grid for knn Model
"""

# Define a dictionary of hyperparameters for tuning a KNN model
parameters = {
    'n_neighbors': [3, 5, 7, 9],  # Número de vecinos
    'weights': ['uniform', 'distance'],  # Tipo de ponderación
    'p': [1, 2]  # Parámetro para la distancia (1 para la distancia de Manhattan, 2 para la Euclidiana)
}

"""Create a Decision knn model"""

model_b_coa_knn = KNeighborsClassifier()

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_b_coa_knn = GridSearchCV(model_b_coa_knn, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_b_coa_knn.fit(X_train_b_coa, y_train_b_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_b_coa_knn = grid_search_b_coa_knn.best_estimator_
print(best_model_b_coa_knn)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_b_coa_knn = grid_search_b_coa_knn.best_params_
print(best_params_b_coa_knn)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_b_coa_knn = grid_search_b_coa_knn.best_score_
print(best_score_b_coa_knn)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_b_coa_knn = best_model_b_coa_knn.predict(X_train_b_coa)

# Evaluation metrics on the training set
accuracy_train_b_coa_knn = accuracy_score(y_train_b_coa, y_pred_train_b_coa_knn)
precision_train_b_coa_knn = precision_score(y_train_b_coa, y_pred_train_b_coa_knn, average='weighted')
# Calculate precision for each class
precision_x_class_train_b_coa_knn = precision_score(y_train_b_coa, y_pred_train_b_coa_knn, average=None)
recall_train_b_coa_knn = recall_score(y_train_b_coa, y_pred_train_b_coa_knn, average='weighted')
# Calculate recall for each class
recall_x_class_train_b_coa_knn = recall_score(y_train_b_coa, y_pred_train_b_coa_knn, average=None)
f1_score_train_b_coa_knn = f1_score(y_train_b_coa, y_pred_train_b_coa_knn, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_b_coa_knn = f1_score(y_train_b_coa, y_pred_train_b_coa_knn, average=None)
jaccard_train_b_coa_knn = jaccard_score(y_train_b_coa, y_pred_train_b_coa_knn, average='weighted')
confusion_train_b_coa_knn = confusion_matrix(y_train_b_coa, y_pred_train_b_coa_knn)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_b_coa_knn)
print("Precision: ", precision_train_b_coa_knn)
print("Precision per class:" , precision_x_class_train_b_coa_knn )
print("Recall: ", recall_train_b_coa_knn)
print("Recall per class:" , recall_x_class_train_b_coa_knn )
print("F1 Score: ", f1_score_train_b_coa_knn)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_b_coa_knn):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_b_coa_knn )
print("Confusion Matrix: ")
print(confusion_train_b_coa_knn)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_b_coa_knn = best_model_b_coa_knn.predict(X_test_b_coa)

# Evaluation metrics on the testing set
accuracy_test_b_coa_knn = accuracy_score(y_test_b_coa, y_pred_test_b_coa_knn)
precision_test_b_coa_knn = precision_score(y_test_b_coa, y_pred_test_b_coa_knn, average='weighted')
# Calculate precision for each class
precision_x_class_test_b_coa_knn = precision_score(y_test_b_coa, y_pred_test_b_coa_knn, average=None)
recall_test_b_coa_knn = recall_score(y_test_b_coa, y_pred_test_b_coa_knn, average='weighted')
# Calculate recall for each class
recall_x_class_test_b_coa_knn = recall_score(y_test_b_coa, y_pred_test_b_coa_knn, average=None)
f1_score_test_b_coa_knn = f1_score(y_test_b_coa, y_pred_test_b_coa_knn, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_b_coa_knn = f1_score(y_test_b_coa, y_pred_test_b_coa_knn, average=None)
jaccard_test_b_coa_knn = jaccard_score(y_test_b_coa, y_pred_test_b_coa_knn, average='weighted')
confusion_test_b_coa_knn = confusion_matrix(y_test_b_coa, y_pred_test_b_coa_knn)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_b_coa_knn)
print("Precision: ", precision_test_b_coa_knn)
print("Precision per class:" , precision_x_class_test_b_coa_knn )
print("Recall: ", recall_test_b_coa_knn)
print("Recall per class:" , recall_x_class_test_b_coa_knn )
print("F1 Score: ", f1_score_test_b_coa_knn)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_b_coa_knn):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_b_coa_knn )
print("Confusion Matrix: ")
print(confusion_test_b_coa_knn)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_b_coa_knn = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained knn model
y_pred_val_b_coa_knn = best_model_b_coa_knn.predict(X_val_b_coa_knn)

# Evaluation metrics on the validation set
accuracy_val_b_coa_knn = accuracy_score(y_val_coastal, y_pred_val_b_coa_knn)
precision_val_b_coa_knn = precision_score(y_val_coastal, y_pred_val_b_coa_knn, average='weighted')
# Calculate precision for each class
precision_x_class_val_b_coa_knn = precision_score(y_val_coastal, y_pred_val_b_coa_knn, average=None)
recall_val_b_coa_knn = recall_score(y_val_coastal, y_pred_val_b_coa_knn, average='weighted')
# Calculate recall for each class
recall_x_class_val_b_coa_knn = recall_score(y_val_coastal, y_pred_val_b_coa_knn, average=None)
f1_score_val_b_coa_knn = f1_score(y_val_coastal, y_pred_val_b_coa_knn, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_b_coa_knn = f1_score(y_val_coastal, y_pred_val_b_coa_knn, average=None)
jaccard_val_b_coa_knn = jaccard_score(y_val_coastal, y_pred_val_b_coa_knn, average='weighted')
confusion_val_b_coa_knn = confusion_matrix(y_val_coastal, y_pred_val_b_coa_knn)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_b_coa_knn)
print("Precision: ", precision_val_b_coa_knn)
print("Precision per class:" , precision_x_class_val_b_coa_knn)
print("Recall: ", recall_val_b_coa_knn)
print("Recall per class:" , recall_x_class_val_b_coa_knn)
print("F1 Score: ", f1_score_val_b_coa_knn)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_b_coa_knn):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_b_coa_knn)
print("Confusion Matrix: ")
print(confusion_val_b_coa_knn)

# Save the trained KNN model to a file
with open('best_model_b_coa_knn.pkl', 'wb') as model_file:
    pickle.dump(best_model_b_coa_knn, model_file)

"""###DT

Hyperparameter Grid for XGBoost Model
"""

# Define a dictionary of hyperparameters for tuning a DT model
parameters = {
    'criterion': ['gini', 'entropy'],  # Criterio para la división de nodos
    'max_depth': [None, 10, 20, 30, 40, 50],  # Profundidad máxima del árbol
    'min_samples_split': [2, 5, 10],  # Número mínimo de muestras para dividir un nodo
    'min_samples_leaf': [1, 2, 4]  # Número mínimo de muestras requeridas en una hoja
}

"""Create a Decision DT model"""

model_b_coa_dt = DecisionTreeClassifier()

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_b_coa_dt = GridSearchCV(model_b_coa_dt, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_b_coa_dt.fit(X_train_b_coa, y_train_b_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_b_coa_dt = grid_search_b_coa_dt.best_estimator_
print(best_model_b_coa_dt)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_b_coa_dt = grid_search_b_coa_dt.best_params_
print(best_params_b_coa_dt)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_b_coa_dt = grid_search_b_coa_dt.best_score_
print(best_score_b_coa_dt)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_b_coa_dt = best_model_b_coa_dt.predict(X_train_b_coa)

# Evaluation metrics on the training set
accuracy_train_b_coa_dt = accuracy_score(y_train_b_coa, y_pred_train_b_coa_dt)
precision_train_b_coa_dt = precision_score(y_train_b_coa, y_pred_train_b_coa_dt, average='weighted')
# Calculate precision for each class
precision_x_class_train_b_coa_dt = precision_score(y_train_b_coa, y_pred_train_b_coa_dt, average=None)
recall_train_b_coa_dt = recall_score(y_train_b_coa, y_pred_train_b_coa_dt, average='weighted')
# Calculate recall for each class
recall_x_class_train_b_coa_dt = recall_score(y_train_b_coa, y_pred_train_b_coa_dt, average=None)
f1_score_train_b_coa_dt = f1_score(y_train_b_coa, y_pred_train_b_coa_dt, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_b_coa_dt = f1_score(y_train_b_coa, y_pred_train_b_coa_dt, average=None)
jaccard_train_b_coa_dt = jaccard_score(y_train_b_coa, y_pred_train_b_coa_dt, average='weighted')
confusion_train_b_coa_dt = confusion_matrix(y_train_b_coa, y_pred_train_b_coa_dt)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_b_coa_dt)
print("Precision: ", precision_train_b_coa_dt)
print("Precision per class:" , precision_x_class_train_b_coa_dt )
print("Recall: ", recall_train_b_coa_dt)
print("Recall per class:" , recall_x_class_train_b_coa_dt )
print("F1 Score: ", f1_score_train_b_coa_dt)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_b_coa_dt):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_b_coa_dt )
print("Confusion Matrix: ")
print(confusion_train_b_coa_dt)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_b_coa_dt = best_model_b_coa_dt.predict(X_test_b_coa)

# Evaluation metrics on the test set
accuracy_test_b_coa_dt = accuracy_score(y_test_b_coa, y_pred_test_b_coa_dt)
precision_test_b_coa_dt = precision_score(y_test_b_coa, y_pred_test_b_coa_dt, average='weighted')
# Calculate precision for each class
precision_x_class_test_b_coa_dt = precision_score(y_test_b_coa, y_pred_test_b_coa_dt, average=None)
recall_test_b_coa_dt = recall_score(y_test_b_coa, y_pred_test_b_coa_dt, average='weighted')
# Calculate recall for each class
recall_x_class_test_b_coa_dt = recall_score(y_test_b_coa, y_pred_test_b_coa_dt, average=None)
f1_score_test_b_coa_dt = f1_score(y_test_b_coa, y_pred_test_b_coa_dt, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_b_coa_dt = f1_score(y_test_b_coa, y_pred_test_b_coa_dt, average=None)
jaccard_test_b_coa_dt = jaccard_score(y_test_b_coa, y_pred_test_b_coa_dt, average='weighted')
confusion_test_b_coa_dt = confusion_matrix(y_test_b_coa, y_pred_test_b_coa_dt)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_b_coa_dt)
print("Precision: ", precision_test_b_coa_dt)
print("Precision per class:" , precision_x_class_test_b_coa_dt )
print("Recall: ", recall_test_b_coa_dt)
print("Recall per class:" , recall_x_class_test_b_coa_dt )
print("F1 Score: ", f1_score_test_b_coa_dt)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_b_coa_dt):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_b_coa_dt )
print("Confusion Matrix: ")
print(confusion_test_b_coa_dt)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_b_coa_dt = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained dt model
y_pred_val_b_coa_dt = best_model_b_coa_dt.predict(X_val_b_coa_dt)

# Evaluation metrics on the validation set
accuracy_val_b_coa_dt = accuracy_score(y_val_coastal, y_pred_val_b_coa_dt)
precision_val_b_coa_dt = precision_score(y_val_coastal, y_pred_val_b_coa_dt, average='weighted')
# Calculate precision for each class
precision_x_class_val_b_coa_dt = precision_score(y_val_coastal, y_pred_val_b_coa_dt, average=None)
recall_val_b_coa_dt = recall_score(y_val_coastal, y_pred_val_b_coa_dt, average='weighted')
# Calculate recall for each class
recall_x_class_val_b_coa_dt = recall_score(y_val_coastal, y_pred_val_b_coa_dt, average=None)
f1_score_val_b_coa_dt = f1_score(y_val_coastal, y_pred_val_b_coa_dt, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_b_coa_dt = f1_score(y_val_coastal, y_pred_val_b_coa_dt, average=None)
jaccard_val_b_coa_dt = jaccard_score(y_val_coastal, y_pred_val_b_coa_dt, average='weighted')
confusion_val_b_coa_dt = confusion_matrix(y_val_coastal, y_pred_val_b_coa_dt)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_b_coa_dt)
print("Precision: ", precision_val_b_coa_dt)
print("Precision per class:" , precision_x_class_val_b_coa_dt )
print("Recall: ", recall_val_b_coa_dt)
print("Recall per class:" , recall_x_class_val_b_coa_dt )
print("F1 Score: ", f1_score_val_b_coa_dt)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_b_coa_dt):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_b_coa_dt )
print("Confusion Matrix: ")
print(confusion_val_b_coa_dt)

# Save the trained DT model to a file
with open('best_model_b_coa_dt.pkl', 'wb') as model_file:
    pickle.dump(best_model_b_coa_dt, model_file)

"""###MLR

Hyperparameter Grid for MLR Model
"""

# Define a dictionary of hyperparameters for tuning a MLR model
parameters = {
    'C': [0.001, 0.01, 0.1, 1, 10, 100],  # Parámetro de regularización
    'solver': ['newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga']  # Método de optimización
}

"""Create a Decision MLR model"""

model_b_coa_mlr = LogisticRegression(max_iter=1000)  # Usamos max_iter para evitar advertencias

"""Hyperparameter Tuning with Cross-Validation"""

# Inform the user to wait during the hyperparameter search
print("Wait a moment...")

# Create a GridSearchCV object for hyperparameter tuning
grid_search_b_coa_mlr = GridSearchCV(model_b_coa_mlr, parameters, cv=5, scoring='accuracy')

# Fit the GridSearchCV object to find the best hyperparameters
grid_search_b_coa_mlr.fit(X_train_b_coa, y_train_b_coa)

"""Best Estimator and Hyperparameters"""

# Print the best estimator found during hyperparameter search
print("Best estimator found:")
best_model_b_coa_mlr = grid_search_b_coa_mlr.best_estimator_
print(best_model_b_coa_mlr)

# Print the best hyperparameters found during hyperparameter search
print("\nBest hyperparameters found:")
best_params_b_coa_mlr = grid_search_b_coa_mlr.best_params_
print(best_params_b_coa_mlr)

# Print the score of the best model in coastal_no_balancing cross-validation
print("\nScore of the best model in coastal_no_balancing cross-validation:")
best_score_b_coa_mlr = grid_search_b_coa_mlr.best_score_
print(best_score_b_coa_mlr)

""" Evaluate the model on the training set"""

# Make predictions on the training set
y_pred_train_b_coa_mlr = best_model_b_coa_mlr.predict(X_train_b_coa)

# Evaluation metrics on the training set
accuracy_train_b_coa_mlr = accuracy_score(y_train_b_coa, y_pred_train_b_coa_mlr)
precision_train_b_coa_mlr = precision_score(y_train_b_coa, y_pred_train_b_coa_mlr, average='weighted')
# Calculate precision for each class
precision_x_class_train_b_coa_mlr = precision_score(y_train_b_coa, y_pred_train_b_coa_mlr, average=None)
recall_train_b_coa_mlr = recall_score(y_train_b_coa, y_pred_train_b_coa_mlr, average='weighted')
# Calculate recall for each class
recall_x_class_train_b_coa_mlr = recall_score(y_train_b_coa, y_pred_train_b_coa_mlr, average=None)
f1_score_train_b_coa_mlr = f1_score(y_train_b_coa, y_pred_train_b_coa_mlr, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_train_b_coa_mlr = f1_score(y_train_b_coa, y_pred_train_b_coa_mlr, average=None)
jaccard_train_b_coa_mlr = jaccard_score(y_train_b_coa, y_pred_train_b_coa_mlr, average='weighted')
confusion_train_b_coa_mlr = confusion_matrix(y_train_b_coa, y_pred_train_b_coa_mlr)

# Print evaluation metrics for the training set
print("Accuracy: ", accuracy_train_b_coa_mlr)
print("Precision: ", precision_train_b_coa_mlr)
print("Precision per class:" , precision_x_class_train_b_coa_mlr )
print("Recall: ", recall_train_b_coa_mlr)
print("Recall per class:" , recall_x_class_train_b_coa_mlr )
print("F1 Score: ", f1_score_train_b_coa_mlr)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_train_b_coa_mlr):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_train_b_coa_mlr )
print("Confusion Matrix: ")
print(confusion_train_b_coa_mlr)

""" Evaluate the model on the test set"""

# Make predictions on the testing set
y_pred_test_b_coa_mlr = best_model_b_coa_mlr.predict(X_test_b_coa)

# Evaluation metrics on the testing set
accuracy_test_b_coa_mlr = accuracy_score(y_test_b_coa, y_pred_test_b_coa_mlr)
precision_test_b_coa_mlr = precision_score(y_test_b_coa, y_pred_test_b_coa_mlr, average='weighted')
# Calculate precision for each class
precision_x_class_test_b_coa_mlr = precision_score(y_test_b_coa, y_pred_test_b_coa_mlr, average=None)
recall_test_b_coa_mlr = recall_score(y_test_b_coa, y_pred_test_b_coa_mlr, average='weighted')
# Calculate recall for each class
recall_x_class_test_b_coa_mlr = recall_score(y_test_b_coa, y_pred_test_b_coa_mlr, average=None)
f1_score_test_b_coa_mlr = f1_score(y_test_b_coa, y_pred_test_b_coa_mlr, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_test_b_coa_mlr = f1_score(y_test_b_coa, y_pred_test_b_coa_mlr, average=None)
jaccard_test_b_coa_mlr = jaccard_score(y_test_b_coa, y_pred_test_b_coa_mlr, average='weighted')
confusion_test_b_coa_mlr = confusion_matrix(y_test_b_coa, y_pred_test_b_coa_mlr)

# Print evaluation metrics for the testing set
print("Accuracy: ", accuracy_test_b_coa_mlr)
print("Precision: ", precision_test_b_coa_mlr)
print("Precision per class:" , precision_x_class_test_b_coa_mlr )
print("Recall: ", recall_test_b_coa_mlr)
print("Recall per class:" , recall_x_class_test_b_coa_mlr )
print("F1 Score: ", f1_score_test_b_coa_mlr)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_test_b_coa_mlr):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_test_b_coa_mlr )
print("Confusion Matrix: ")
print(confusion_test_b_coa_mlr)

""" Evaluate the model on the validation set"""

# Transform the validation data using the scaler trained on the validation data
X_val_b_coa_mlr = scaler_coa.transform(X_val_coastal)

# Make predictions on the validation set using the trained MLR model
y_pred_val_b_coa_mlr = best_model_b_coa_mlr.predict(X_val_b_coa_mlr)

# Evaluation metrics on the validation set
accuracy_val_b_coa_mlr = accuracy_score(y_val_coastal, y_pred_val_b_coa_mlr)
precision_val_b_coa_mlr = precision_score(y_val_coastal, y_pred_val_b_coa_mlr, average='weighted')
# Calculate precision for each class
precision_x_class_val_b_coa_mlr = precision_score(y_val_coastal, y_pred_val_b_coa_mlr, average=None)
recall_val_b_coa_mlr = recall_score(y_val_coastal, y_pred_val_b_coa_mlr, average='weighted')
# Calculate recall for each class
recall_x_class_val_b_coa_mlr = recall_score(y_val_coastal, y_pred_val_b_coa_mlr, average=None)
f1_score_val_b_coa_mlr = f1_score(y_val_coastal, y_pred_val_b_coa_mlr, average='weighted')
# Calculate f1 score for each class
f1_score_x_class_val_b_coa_mlr = f1_score(y_val_coastal, y_pred_val_b_coa_mlr, average=None)
jaccard_val_b_coa_mlr = jaccard_score(y_val_coastal, y_pred_val_b_coa_mlr, average='weighted')
confusion_val_b_coa_mlr = confusion_matrix(y_val_coastal, y_pred_val_b_coa_mlr)

# Print evaluation metrics for the validation set
print("Accuracy: ", accuracy_val_b_coa_mlr)
print("Precision: ", precision_val_b_coa_mlr)
print("Precision per class:" , precision_x_class_val_b_coa_mlr )
print("Recall: ", recall_val_b_coa_mlr)
print("Recall per class:" , recall_x_class_val_b_coa_mlr )
print("F1 Score: ", f1_score_val_b_coa_mlr)
# Print F1-score for each class
for clase, f1 in enumerate(f1_score_x_class_val_b_coa_mlr):
    print(f"F1-score for the class {clase}: {f1}")
print("jaccard:" , jaccard_val_b_coa_mlr )
print("Confusion Matrix: ")
print(confusion_val_b_coa_mlr)

# Save the trained MLR model to a file
with open('best_model_b_coa_mlr.pkl', 'wb') as model_file:
    pickle.dump(best_model_b_coa_mlr, model_file)

# Save the scaler used for preprocessing to a file
with open('scaler_coa.pkl', 'wb') as scaler_file:
    pickle.dump(scaler_coa, scaler_file)

print("Final")